{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#installation","title":"Installation","text":"<p>To install the package, run the following command:</p> <pre><code>pip install richapi\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>**RichAPI is designed to simplify FastAPI projects by automatically generating documented HTTP responses from HTTPException without extra effort! \ud83c\udf89 ** This package is planned to have more features for now that might be essential for any FastAPI project later.</p> <p>There are multiple way you can do that, first way is simply to regenerate the OpenAPI schema by running the following command:</p> <pre><code>from richapi import enrich_openapi\nfrom fastapi import FastAPI\n\napp = FastAPI()\n# add your routers ....\napp.openapi = enrich_openapi(app)\n</code></pre> <p>You can also compile the OpenAPI schema and save it to a file, by running this command from CLI:</p> <pre><code>richapi compile module.app:app\n</code></pre> <p>And then, you can run the following code to load the compiled OpenAPI schema:</p> <pre><code>from richapi import load_openapi\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nwith open(\"openapi.json\") as open_api_json:\n    app.openapi = load_openapi(app, json.loads(open_api_json.read()))\n</code></pre> <p>My recommended way</p> <p>I personally recommend the second way, because it is better to have it compiled and saved to file, because there are static analysis running on the OpanAPI generator and your source code which isn't very ideal to be running in production.</p>"},{"location":"#example","title":"Example","text":"<p>Imagine this application;</p> <pre><code>import random\n\nfrom fastapi import FastAPI\n\nfrom richapi.exc_parser.openapi import compile_openapi_from_fastapi, enrich_openapi\nfrom richapi.exc_parser.protocol import BaseHTTPException\n\napp = FastAPI()\napp.openapi = enrich_openapi(app)\n\n\nclass InteralServer(BaseHTTPException):\n    status_code = 500\n    detail = \"Internal server error\"\n\n\nclass NotFound(BaseHTTPException):\n    status_code = 501\n    detail = \"Not found\"\n\n\nclass GatewayError(BaseHTTPException):\n    status_code = 502\n    detail = \"Gateway error\"\n\n\ndef very_nested():\n    value = InteralServer\n    raise value\n\n\ndef nested():\n    try:\n        very_nested()\n    except InteralServer:\n        raise NotFound\n\n\n@app.get(\"/home\")\ndef read_root() -&gt; dict[str, str]:\n    if random.choice([True, False]):\n        nested()\n\n    elif random.choice([True, False]):\n        raise GatewayError()\n\n    return {\"Hello\": \"World\"}\n</code></pre> <p>What would you see WITHOUT RichAPI: </p> <p>After compiling OpenAPI WITH RichAPI (extended with all possible exceptions coming from your router): </p>"},{"location":"#conventions-very-important","title":"Conventions (VERY IMPORTANT)","text":"<p>There are some conventions about how to raise exceptions and etc. You may read the conventions to know more about them. The way library works is that it is a mini compiler using Abstract Syntax Tree and functions global to extract exceptions and their responses, and then it generates the OpenAPI schema from them. So there are limitations to what it can do, and you may need to follow the conventions to get the best out of it. Anything that is not following the conventions MAY be ignored by the compiler, and there is no plan to support them in the future, because it is not possible to support all the ways you can raise exceptions in Python... To give you an example, you may download a source code from internet and then use 'eval' function to run it dynamically, and there is no way to know what exceptions you may raise in that code, so it is impossible to support all the ways you can raise exceptions in Python.</p>"},{"location":"advance/","title":"Advance Usage","text":""},{"location":"advance/#advance","title":"Advance","text":"<p>This is guideline for how to use the library in more advanced ways.</p>"},{"location":"advance/#customization-of-the-openapi-schema","title":"Customization of the OpenAPI schema","text":"<p>Sometimes, your exceptions is more than 'details'. In that case, you can very explicitly define the exception JSON schema inside the exception class. You may even use Pydantic to define the schema dynamically so you don't need to write the schema manually.</p> <p>All you need to do, is to return type HTTPExceptionSchema correctly on the method <code>get_json_schema</code> of your exception class which you inherited from <code>BaseHTTPException</code>.</p> <p>Imagine you are writing an exception that is returning a user balance and a time to retry again a failed bank transaction, you can define the schema like this:</p> <pre><code>from richapi import  BaseHTTPException\nfrom richapi.exc_parser import HTTPExceptionSchema\nfrom pydantic import create_model\n\nclass YourException(BaseHTTPException):\n    user_balance: int\n    retry_again_in: int\n    status_code: int = 400\n\n    @classmethod\n    def get_json_schema(cls) -&gt; HTTPExceptionSchema:\n        schema = create_model(name, user_balance=(int, ...), retry_again_in=(int, ...))\n        return HTTPExceptionSchema(\n            schema_name=\"YourException\",\n            schema_desc=\"This is a custom exception\",\n            status_code=cls.status_code,\n            response_schema_json=schema.model_json_schema(),\n        )\n</code></pre> <p>Remember that the responsbility of raising and returning the correct data on FastAPI is not library responsibility, but the responsibility of the developer. The library is only responsible for generating the OpenAPI schema by looking at the functions and classes that are raising exceptions.</p>"},{"location":"conventions/","title":"Conventions","text":""},{"location":"conventions/#conventions","title":"Conventions","text":"<p>This is guideline for how to raise exceptions so that the library can generate the OpenAPI schema from them.</p> <p>Since the library is a mini compiler using Abstract Syntax Tree and functions global to extract exceptions and their responses, there are some conventions that you need to follow to get the best out of it.</p> <p>Keep in mind that if you don't follow these conventions, there would be alot false positive and false negative cases, and the library may not be able to extract the exceptions and their responses correctly.</p>"},{"location":"conventions/#inherit-from-richapibasehttpexception","title":"Inherit from <code>richapi.BaseHTTPException</code>","text":"<p>Exceptions are better to be very concrete, without having any dynamic data in them. So that using <code>raise Class</code> is enough to raise them.</p> <p>Exceptions ideally should inherit from <code>richapi.BaseHTTPException</code>. Check the ideal case below:</p> <pre><code>from richapi import BaseHTTPException\n\nclass UserNotFound(BaseHTTPException):\n    status_code = 404\n    details = \"User not found\"\n</code></pre> <p>And then, only writing <code>raise UserNotFound</code> is enough to raise the exception. This is most ideal case.</p>"},{"location":"conventions/#avoiding-dynamic-data-in-the-constructor-of-the-exceptions","title":"Avoiding dynamic data in the constructor of the exceptions","text":"<p>Exceptions should not have any dynamic data in them. For example the code below is NOT ideal:</p> <pre><code>user_id = 1 # imaginary dynamic data\nerror_message = f\"User {user_id} is not allowed to perform this action\"\nraise FooException(detail=error_message)\n</code></pre> <p>Since the library is using static analyzers to extract the exceptions, it is not possible to extract the dynamic data from the exceptions. (or rather very hard to do so)</p>"},{"location":"conventions/#avoiding-usage-of-magic-methods","title":"Avoiding usage of magic methods","text":"<p>Magic methods are implicit, therefore extracting them from the abstract syntax tree is exteremly hard and equal to rewriting the Python interpreter.</p> <p>One example that you should not do in your code:</p> <pre><code>class Foo:\n    def __init__(self, bar):\n        self.bar = bar\n\n    def __eq__(self, other):\n        raise HTTPException(status_code=400, detail=\"This is not allowed\")\n</code></pre>"},{"location":"conventions/#keep-it-simple","title":"Keep it simple","text":"<p>The ideal way to raise exceptions is to keep it simple from syntax point of view;</p> <p>This is very ideal and can be easily parsed and compiled.</p> <pre><code>raise HTTPException(status_code=400, detail=\"This is not allowed\")\n</code></pre> <p>But the below example MAY not be parsed correctly:</p> <pre><code>exc = lambda: HTTPException\nraise exc()(status_code=400, detail=\"This is not allowed\")\n</code></pre> <p>Keep it simple, keep the exception type next to raise keyword; without any dynamic data in the constructor. This help the library to extract the exceptions and their responses and guarantee that they are correctly compiled into the OpenAPI schema.</p>"}]}