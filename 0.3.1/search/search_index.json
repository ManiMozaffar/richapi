{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#installation","title":"Installation","text":"<p>To install the package, run the following command:</p> <pre><code>pip install richapi\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>RichAPI is designed to simplify FastAPI projects by automatically generating documented HTTP responses from HTTPException without extra effort! \ud83c\udf89</p> <p>This package is planned to have more features for now that might be essential for any FastAPI project later.</p> <p>There are multiple way you can do that, first way is simply to regenerate the OpenAPI schema by running the following command:</p> <pre><code>from richapi import enrich_openapi\nfrom fastapi import FastAPI\n\napp = FastAPI()\n# add your routers ....\napp.openapi = enrich_openapi(app)\n</code></pre> <p>You can also compile the OpenAPI schema and save it to a file, by running this command from CLI:</p> <pre><code>richapi compile module.app:app\n</code></pre> <p>And then, you can run the following code to load the compiled OpenAPI schema:</p> <pre><code>from richapi import load_openapi\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nwith open(\"openapi.json\") as open_api_json:\n    app.openapi = load_openapi(app, json.loads(open_api_json.read()))\n</code></pre> <p>My recommended way</p> <p>I personally recommend the second way, because it is better to have it compiled and saved to file, because there are static analysis running on the OpanAPI generator and your source code which isn't very ideal to be running in production.</p>"},{"location":"#customization-of-exception","title":"Customization of Exception","text":"<p>Sometimes, your exceptions is more than 'details'. You may want to put some extra information for the client to understand and parse the error better. In that case, please follow these steps:</p> <ol> <li>Add the exception handler from richapi to your FastAPI app.</li> <li>Inhert from <code>richapi.RichHTTPException</code>, and make it a dataclass.</li> <li>To override status, simply set the <code>status_code</code> attribute on the class without type annotation.</li> <li>Raise that exception somewhere in your code and you'll see the schema on swagger!</li> </ol> <p>Example:</p> <pre><code>import fastapi\nimport fastapi.security\nfrom pydantic import BaseModel\nfrom pydantic.dataclasses import dataclass\n\nfrom richapi.exc_parser.handler import add_exc_handler\nfrom richapi.exc_parser.openapi import enrich_openapi\nfrom richapi.exc_parser.protocol import RichHTTPException\n\napp = fastapi.FastAPI()\napp.openapi = enrich_openapi(app)\nadd_exc_handler(app)\n\n\n@dataclass\nclass NotEnoughBalance(RichHTTPException):\n    \"\"\"Custom exception for user balance\"\"\"\n\n    user_id: int\n    balance: float\n    status_code = 403\n\n\nclass SuccessResponse(BaseModel):\n    balance: float\n\n\n@app.post(\"/payment\")\nasync def make_payment() -&gt; SuccessResponse:\n    raise NotEnoughBalance(user_id=1, balance=0.5)\n</code></pre> <p>Final Result: </p>"},{"location":"#conventions-very-important","title":"Conventions (VERY IMPORTANT)","text":"<p>There are some conventions about how to raise exceptions and etc. You may read the conventions to know more about them. The way library works is that it is a mini compiler using Abstract Syntax Tree and functions global to extract exceptions and their responses, and then it generates the OpenAPI schema from them. So there are limitations to what it can do, and you may need to follow the conventions to get the best out of it. Anything that is not following the conventions MAY be ignored by the compiler, and there is no plan to support them in the future, because it is not possible to support all the ways you can raise exceptions in Python... To give you an example, you may download a source code from internet and then use 'eval' function to run it dynamically, and there is no way to know what exceptions you may raise in that code, so it is impossible to support all the ways you can raise exceptions in Python.</p>"},{"location":"#example","title":"Example","text":"<p>Imagine this application;</p> <pre><code>import random\n\nfrom fastapi import FastAPI\n\nfrom richapi.exc_parser.openapi import compile_openapi_from_fastapi, enrich_openapi\nfrom richapi.exc_parser.protocol import BaseHTTPException\n\napp = FastAPI()\napp.openapi = enrich_openapi(app)\n\n\nclass InteralServer(BaseHTTPException):\n    status_code = 500\n    detail = \"Internal server error\"\n\n\nclass NotFound(BaseHTTPException):\n    status_code = 501\n    detail = \"Not found\"\n\n\nclass GatewayError(BaseHTTPException):\n    status_code = 502\n    detail = \"Gateway error\"\n\n\ndef very_nested():\n    value = InteralServer\n    raise value\n\n\ndef nested():\n    try:\n        very_nested()\n    except InteralServer:\n        raise NotFound\n\n\n@app.get(\"/home\")\ndef read_root() -&gt; dict[str, str]:\n    if random.choice([True, False]):\n        nested()\n\n    elif random.choice([True, False]):\n        raise GatewayError()\n\n    return {\"Hello\": \"World\"}\n</code></pre> <p>What would you see WITHOUT RichAPI: </p> <p>After compiling OpenAPI WITH RichAPI (extended with all possible exceptions coming from your router): </p>"},{"location":"advance/","title":"Advance Usage","text":""},{"location":"advance/#advance","title":"Advance","text":"<p>This is guideline for how to use the library in more advanced ways.</p>"},{"location":"advance/#customization-of-the-openapi-schema","title":"Customization of the OpenAPI schema","text":"<p>All you need to do, is to return type HTTPExceptionSchema correctly on the method <code>get_json_schema</code> of your exception class which you inherited from <code>BaseHTTPException</code>.</p> <p>Imagine you are writing an exception that is returning a user balance and a time to retry again a failed bank transaction, you can define the schema like this:</p> <pre><code>from richapi import  BaseHTTPException\nfrom richapi.exc_parser import HTTPExceptionSchema\nfrom pydantic import create_model\n\nclass YourException(BaseHTTPException):\n    user_balance: int\n    retry_again_in: int\n    status_code: int = 400\n\n    @classmethod\n    def get_json_schema(cls) -&gt; HTTPExceptionSchema:\n        schema = create_model(name, user_balance=(int, ...), retry_again_in=(int, ...))\n        return HTTPExceptionSchema(\n            schema_name=\"YourException\",\n            schema_desc=\"This is a custom exception\",\n            status_code=cls.status_code,\n            response_schema_json=schema.model_json_schema(),\n        )\n</code></pre> <p>If your intention is to have a custom response schema, then recommended way is to use custom exception feature.</p>"},{"location":"advance/#finding-exceptions-in-other-modules","title":"Finding exceptions in other modules","text":"<p>By default, the library only looks at the FastAPI app module to search for exceptions. This is to avoid parsing countless dependency modules that are not related to the FastAPI app. But sometimes you may be using some other libraries that raises HTTPExceptions. For example using a third library for JWT authentication.</p> <p>In that case, you can simply pass the module name to the <code>parse_exceptions</code> function.</p> <pre><code>from richapi import enrich_openapi\nfrom fastapi import FastAPI\n\napp = FastAPI()\n# add your routers ....\napp.openapi = enrich_openapi(app, [\"your_module_name\", \"some-other-package\"])\n</code></pre>"},{"location":"conventions/","title":"Conventions","text":"<p>This is guideline for how to raise exceptions so that the library can generate the OpenAPI schema from them.</p> <p>Since the library is a mini compiler using Abstract Syntax Tree and functions global to extract exceptions and their responses, there are some conventions that you need to follow to get the best out of it.</p> <p>Keep in mind that if you don't follow these conventions, there would be alot false positive and false negative cases, and the library may not be able to extract the exceptions and their responses correctly.</p>"},{"location":"conventions/#inherit-from-richapibasehttpexception-or-richapirichhttpexception","title":"Inherit from <code>richapi.BaseHTTPException</code> or <code>richapi.RichHTTPException</code>","text":"<p>Exceptions are better to be very concrete, without having any dynamic data in them. So that using <code>raise Class</code> is enough to raise them.</p> <p>Exceptions ideally should inherit from <code>richapi.BaseHTTPException</code>. Check the ideal case below:</p> <pre><code>from richapi import BaseHTTPException\n\nclass UserNotFound(BaseHTTPException):\n    status_code = 404\n    details = \"User not found\"\n</code></pre> <p>And then, only writing <code>raise UserNotFound</code> is enough to raise the exception. This is most ideal case.</p> <p>Expected Behavior</p> <p>Library MIGHT skip adding the exception to the OpenAPI schema if it could not gather necessary and missing informations from the abstract syntax tree.</p>"},{"location":"conventions/#avoiding-dynamic-data-in-the-constructor-of-the-exceptions-and-stringifying-errors","title":"Avoiding dynamic data in the constructor of the exceptions and stringifying errors","text":"<p>Exceptions should not have any dynamic data in them. For example the code below is NOT ideal:</p> <pre><code>user_id = 1 # imaginary dynamic data\nerror_message = f\"User {user_id} is not allowed to perform this action\"\nraise FooException(detail=error_message)\n</code></pre> <p>This is not even a good practice to begin with, because ideally your RestAPI should not be aware of what text shown to the user. The error message should be handled by the client, not the server. There is a better way you can do to pass information to client about the error. Read the advance usage section for more information.</p> <p>Since the library is using static analyzers to extract the exceptions, it is not possible to extract the dynamic data from the exceptions. (or rather very hard to do so)</p> <p>Expected Behavior</p> <p>Library WILL add the exception to the OpenAPI schema, but the detail of response won't be precisely shown and instead you will see <code>str</code> as the response type. However, if you follow this convention, library exactly show the string that you have written in the <code>detail</code> attribute of the exception as a literal string type.</p>"},{"location":"conventions/#avoiding-usage-of-magic-methods","title":"Avoiding usage of magic methods","text":"<p>Magic methods are implicit, therefore extracting them from the abstract syntax tree is exteremly hard and equal to rewriting the Python interpreter.</p> <p>One example that you should not do in your code:</p> <pre><code>class Foo:\n    def __init__(self, bar):\n        self.bar = bar\n\n    def __eq__(self, other):\n        raise HTTPException(status_code=400, detail=\"This is not allowed\")\n</code></pre> <p>Expected Behavior</p> <p>Library WILL skip adding the exception to the OpenAPI schema.</p>"},{"location":"conventions/#keep-it-simple","title":"Keep it simple","text":"<p>The ideal way to raise exceptions is to keep it simple from syntax point of view;</p> <p>This is very ideal and can be easily parsed and compiled.</p> <pre><code>raise HTTPException(status_code=400, detail=\"This is not allowed\")\n</code></pre> <p>But the below example MAY not be parsed correctly:</p> <pre><code>exc = lambda: HTTPException\nraise exc()(status_code=400, detail=\"This is not allowed\")\n</code></pre> <p>Keep it simple, keep the exception type next to raise keyword; without any dynamic data in the constructor. This help the library to extract the exceptions and their responses and guarantee that they are correctly compiled into the OpenAPI schema.</p> <p>Expected Behavior</p> <p>Library MIGHT skip adding the exception to the OpenAPI schema depending on how complicated the exception raising is.</p>"},{"location":"conventions/#always-provide-type-annotations-for-classinstance-attributes-and-function-arguments","title":"Always Provide Type Annotations For Class/Instance Attributes And Function Arguments","text":"<p>To enable accurate type resolution during static analysis, always provide type annotations for your variables, function parameters, and return types. Without type annotations, it's nearly impossible for the library to infer types correctly, which may lead to false positives or negatives. That stands for class attributes and function arguments.</p> <p>Example:</p> <pre><code>class Foo:\n    def foo(self) -&gt; None:\n        raise HTTPException(status_code=400, detail=\"This is not allowed\")\n\nclass Baz:\n    foo: Foo # this is very important to have type annotations for class/instance attributes\n\n    def __init__(self, foo: Foo):\n        self.foo = foo\n\n    def foo(self) -&gt; None:\n        # if you don't type annotate, RichAPI doesn't have any idea about the type of self.fo\n        self.foo.foo()\n</code></pre> <p>Expected Behavior</p> <p>Library WILL skip adding exceptions to the OpenAPI schema if it cannot resolve types due to missing annotations.</p>"},{"location":"implementation/","title":"Implementation detail","text":"<p>Library is made of few components working together to generate the OpenAPI schema.</p>"},{"location":"implementation/#exception-finder","title":"Exception Finder","text":"<ul> <li>Input: A function</li> <li>Output: List of exception type with their <code>raise</code> abstract syntax tree nodes</li> </ul> <ol> <li>Check if this function was ever analyzed before, if yes, then skip.</li> <li>Get source code of the callable object.</li> <li>Parse the source code to AST.</li> <li>Start visiting every node in the callable.</li> <li>Track assigmnets to a variable.</li> <li>On visiting a node ...<ol> <li>If the node is a <code>raise</code> statement, then extract the exception type and return as output.</li> <li>If a node is a <code>call</code> statement, then recursively visit the callable that is being called.</li> <li>If a node is an <code>assign</code> statement, then track the variable name and the assigned value.</li> <li>If a node is an <code>attribute</code> statement, then track the attribute name and the parent object. Might have to recursively visit the parent object.</li> </ol> </li> </ol> <p>Note that the only way to extract the exception type is to use the tracked assigmnets with <code>eval</code> function so that the type is returned. That's why it's best to run the library on CLI rather than on the fly. To understand this better look at below code;</p> <pre><code>def foo():\n    err = Exception\n    raise err\n</code></pre> <p>The only way that you can understand err is Exception is to keep tracking the assignments and then use <code>eval</code> to get the type. Running <code>eval(\"err\")</code> will get you the type of the error which is a requirement to function properly.</p>"},{"location":"implementation/#fastapi-excption-parser","title":"FastAPI Excption Parser","text":"<ul> <li>Input: An excpetion with its <code>raise</code> AST node</li> <li>Output: Json schema</li> </ul> <ol> <li>Check if the exception type already has a schema defined by itself.<ul> <li>If yes, then simply construct the Json schema from that.</li> <li>If not, continue to the next step.</li> </ul> </li> <li>Analyze and extract arg and kwargs from the <code>raise</code> AST node.</li> <li>Try to construct the exception schema from the arguments.</li> <li>Try to dynamically generate the schema using Pydantic.</li> <li>Return the schema if successfully generated, otherwise return None.</li> </ol>"},{"location":"implementation/#openapi-generator","title":"OpenAPI Generator","text":"<ul> <li>Input: FastAPI Module, Previous OpenAPI schema</li> <li>Output: OpenAPI schema</li> </ul> <ol> <li>Iterating over all fastapi routers to analyze each at a time.</li> <li>Each router has few callable dependency. All callable dependencies are analyzed using <code>Exception Finder</code>.</li> <li>Result of the <code>Exception Finder</code> is passed to the <code>FastAPI Excption Parser</code> to get the Json schema.</li> <li>Using the Json schema, the OpenAPI schema is extended with new responses for that router.</li> <li>The result is cached so that the same router is not analyzed again.</li> </ol>"}]}